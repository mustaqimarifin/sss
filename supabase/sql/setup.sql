-- Create a USER table
create table user (
  id uuid references auth.users not null,
  "lastLogin" timestamp with time zone,
  "name" text unique,
  handle text,
  picture text,
  email text,

  primary key (id),
  unique ("name"),
  constraint "name"_length check (char_length("name") >= 3)
);

alter table user enable row level security;

create policy "User profiles are public."
  on user for select
  using ( true );

create policy "Users can insert their own profile."
  on user for insert
  with check ( auth.uid() = id );

create policy "Users can update own profile."
  on user for update
  using ( auth.uid() = id );


-- Trigger DB to handle USER info
create function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.user (id, "name", handle, picture)
  values (new.id, new.raw_user_meta_data->>'name', new.raw_user_meta_data->>'user_name' as handle,new.raw_user_meta_data->>'avatar_url' as picture);
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
  
-- Create a table for Pages
create table "page" (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "url" text UNIQUE NOT NULL,
  vcount bigint DEFAULT 1 NOT NULL,
  updated timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);


-- Create a table for Comments
create table comment (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "createdAt" timestamp with time zone default now() not null,
    "updatedAt" timestamp with time zone default now() null,
    "text" text not null,
    "pageId" bigint not null references "page" (id),
    "authorId" uuid not null references user (id),
    "parentId" text null references comment (id),


    primary key (id),
);


alter table comment enable row level security;

create policy "comments are viewable by everyone."
    on comment for select
    using ( true );

create policy "Users can post as themselves."
    on comment for insert
    with check ( auth.uid() = "authorId" );


-- Create a table for Votes
create table vote (
    "authorId" uuid not null references user (id),
    "voteId" bigint not null references comment (id),
    "value" bigint not null,

    primary key ("voteId", "authorId"),
    constraint vote_quantity check (value <= 1 and value >= -1)
);

alter table vote enable row level security;

create policy "Votes are public"
    on vote for select
    using ( true );

create policy "Users can vote"
    on vote for insert
    with check (auth.uid() = "authorId");

create policy "Users can update their own vote"
    on vote for update
    using ( auth.uid() = "authorId" );


-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table comment, vote, user, "page";




--Create Views to assist querying and managing DB

drop view if exists "authorComments" cascade;
create view "authorComments" as
    select
        x.id,
        x."createdAt",
        x."updatedAt",
        x.text,
        x."authorId",
        x."parentId",
        to_jsonb(u) as author
    from
        comment x
        inner join user u on x."authorId" = u.id;

drop view if exists "linearView" cascade;
create view "linearView" as
    select
        root_c.*,
        to_jsonb(parent_c) as parent,
        coalesce(json_agg(children_c) filter (where children_c.id is not null), '[]') as replies
    from
        "authorComments" root_c
        inner join "authorComments" parent_c on root_c."parentId" = parent_c.id
        left join "authorComments" children_c on children_c."parentId" = root_c.id
    group by
        root_c.id,
        root_c."createdAt",
        root_c."updatedAt",
        root_c.text,
        root_c."authorId",
        root_c."parentId",
        root_c.author,
        parent_c.*;

drop view if exists "authorVotes" cascade;
create or replace view "authorVotes" as
    select
        x.id,
        x."createdAt",
        x."updatedAt",
        x.text,
        x."authorId",
        x."parentId",
        x."author",
        coalesce (
            sum (v.value) over w,
            0
        ) as "vote",
        sum (case when v.value > 0 then 1 else 0 end) over w as "upvote",
        sum (case when v.value < 0 then 1 else 0 end) over w as "downvote"
        -- (select case when auth.uid() = v."userId" then v.value else 0 end) as "userVoteValue"
    from
        "authorComments" x
        left join vote v on x.id = v."voteId"
    window w as (
        partition by v."voteId"
    );

drop view if exists "commentThread", "commentsAndVotes" cascade;
create recursive view "commentThread" (
    id,
    "createdAt",
    "updatedAt",
   "text",
    "authorId",
    "parentId",
    "author",
    "vote",
    "upvote",
    "downvote",
    "depth",
    "path",
    "pathvoteRecent",
    "pathLeastRecent",
    "pathMostRecent"
) as
    select
           id,
    "createdAt",
    "updatedAt",
   "text",
    "authorId",
    "parentId",
    "author",
    "vote",
    "upvote",
    "downvote",
        0 as depth,
        array[id] as "path",
        array[id] as "pathvoteRecent",
        array[id] as "pathLeastRecent",
        array[id] as "pathMostRecent"
    from
        "authorVotes"
    where
        "parentId" is null
    union
    select
        x1.id,
        x1.id,
        x1.cnp_id,
        x1."name",
        x1.image,
        x1.slug,
        x1.url,
        x1."createdAt",
        x1."updatedAt",
        x1.text,
        x1."authorId",
        x1."parentId",
        x1."author",
        x1."vote",
        x1."upvote",
        x1."downvote",
        x2.depth + 1 as depth,
        x2."path" || x1.id::bigint as "path",
        x2."pathvoteRecent" || -x1."vote"::bigint || -extract(epoch from x1."createdAt")::bigint || x1.id as "pathvoteRecent",
        x2."pathLeastRecent" || extract(epoch from x1."createdAt")::bigint || x1.id as "pathLeastRecent",
        x2."pathMostRecent" || -extract(epoch from x1."createdAt")::bigint || x1.id as "pathMostRecent"
    from
        "authorVotes" x1
        join "commentThread" x2 on x1."parentId" = x2.id;

create or replace view "commentsAndVotes" as
    select distinct on (id)
        id,
        "createdAt",
        "updatedAt",
       "text",
        "authorId",
        "parentId",
        "author",
        "vote",
        "upvote",
        "downvote",
        "depth",
        "path",
        "pathvoteRecent",
        "pathLeastRecent",
        "pathMostRecent",
        coalesce(
            (
                select
                    v."value"
                from
                    vote v
                where
                    auth.uid() = v."authorId" and v."voteId" = id
            ),
            0
        ) as "userVoteValue"
    from "commentThread";
